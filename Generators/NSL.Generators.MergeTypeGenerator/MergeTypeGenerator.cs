using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NSL.Generators.MergeTypeGenerator.Attributes;
using NSL.Generators.Utils;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace NSL.Generators.MergeTypeGenerator
{
    [Generator]
    internal class MergeTypeGenerator : ISourceGenerator
    {
        #region ISourceGenerator

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is MergeTypeAttributeSyntaxReceiver methodSyntaxReceiver)
            {
                ProcessMergeTypes(context, methodSyntaxReceiver);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() =>
                new MergeTypeAttributeSyntaxReceiver());
        }

        #endregion

        private void ProcessMergeTypes(GeneratorExecutionContext context, MergeTypeAttributeSyntaxReceiver methodSyntaxReceiver)
        {
            //if (!Debugger.IsAttached)
            //    Debugger.Launch();

            foreach (var item in methodSyntaxReceiver.MergeToTypeTypes)
            {
                ProcessMergeType(context, item);
            }
        }

        private void ProcessMergeType(GeneratorExecutionContext context, TypeDeclarationSyntax type)
        {
            if (!type.HasPartialModifier())
                return;

            var typeClass = type as ClassDeclarationSyntax;

            var typeSem = context.Compilation.GetSemanticModel(typeClass.SyntaxTree);

            var classBuilder = new CodeBuilder();

            classBuilder.AppendComment(() =>
            {
                classBuilder.AppendLine($"Auto Generated by NSL MergeType. Please dont change this file");
            });

            classBuilder.CreatePartialClass(typeClass, () =>
            {
                var attrbs = typeClass.AttributeLists
                .SelectMany(x => x.Attributes)
                .Where(x => x.GetAttributeFullName().Equals(MergeToTypeAttributeFullName))
                .ToArray();

                foreach (var attr in attrbs)
                {
                    //if (!Debugger.IsAttached)
                    //    Debugger.Launch();

                    var typeSymb = typeSem.GetDeclaredSymbol(type) as ITypeSymbol;

                    var toType = attr.ArgumentList.Arguments.First().GetAttributeTypeParameterValueSymbol(typeSem) ;

                    var declaration = toType.DeclaringSyntaxReferences.First().GetSyntax() as TypeDeclarationSyntax;

                    classBuilder.AppendLine($"{(declaration.HasInternalModifier() ? "internal" : "public")} void FillTo({toType.Name} toFill)");

                    classBuilder.AppendLine("{");

                    classBuilder.NextTab();


                    var cType = toType;

                    List<ISymbol> toMembers = new List<ISymbol>();

                    do
                    {
                        toMembers.AddRange(cType.GetMembers());

                        cType = cType.BaseType;
                    } while (cType != null);


                    cType = typeSymb;

                    List<ISymbol> members = new List<ISymbol>();

                    do
                    {
                        members.AddRange(cType.GetMembers());

                        cType = cType.BaseType;
                    } while (cType != null);


                    foreach (var item in members)
                    {
                        var fMember = toMembers.FirstOrDefault(x => x.Name.Equals(item.Name) && x.DeclaredAccessibility == Accessibility.Public);

                        if (fMember == default || (fMember is IPropertySymbol fps && fps.SetMethod == default))
                            continue;

                        if (item is IPropertySymbol ps)
                        {
                            var ignore = ps.GetAttributes()
                            .Where(x => x.AttributeClass.Name.Equals(MergeToTypeIgnoreAttributeFullName))
                            .Any(q => q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                            if (ignore)
                                continue;

                            if (ps.GetMethod == null)
                                continue;
                        }
                        else if (item is IFieldSymbol fs)
                        {
                            var ignore = fs.GetAttributes()
                            .Where(x => x.AttributeClass.Name.Equals(MergeToTypeIgnoreAttributeFullName))
                            .Any(q => q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                            if (ignore)
                                continue;
                        }
                        else
                            continue;

                        classBuilder.AppendLine($"toFill.{item.Name} = {item.Name};");
                    }

                    classBuilder.PrevTab();

                    classBuilder.AppendLine("}");
                }
            });

            // Visual studio have lag(or ...) cannot show changes any time
            //#if DEVELOP
#pragma warning disable RS1035 // Do not use APIs banned for analyzers
            //System.IO.File.WriteAllText($@"C:\Work\temp\{typeClass.GetTypeClassName()}.mergetype.cs", classBuilder.ToString());
#pragma warning restore RS1035 // Do not use APIs banned for analyzers
            //#endif

            context.AddSource($"{typeClass.GetTypeClassName()}.mergetype.cs", classBuilder.ToString());
        }



        private readonly string MergeToTypeAttributeFullName = typeof(MergeToTypeAttribute).Name;
        private readonly string MergeToTypeIgnoreAttributeFullName = typeof(MergeToTypeIgnoreAttribute).Name;
    }
}
