using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using NSL.Generators.FillTypeGenerator.Attributes;
using NSL.Generators.FillTypeGenerator.Utils;
using NSL.Generators.Utils;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Security.Claims;
using System.Text;

namespace NSL.Generators.FillTypeGenerator
{
    [Generator]
    internal class FillTypeGenerator : IIncrementalGenerator
    {
        #region ISourceGenerator

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var pip = context.SyntaxProvider.CreateSyntaxProvider(
                FillTypeAttributeSyntaxReceiver.OnVisitSyntaxNode,
                (syntax, _) => syntax);

            context.RegisterSourceOutput(pip, ProcessFillTypes);
        }

        #endregion

        private void ProcessFillTypes(SourceProductionContext context, GeneratorSyntaxContext item)
        {
            var @class = (TypeDeclarationSyntax)item.Node;

            try
            {
                ProcessFillType(context, item, @class);
            }
            catch (Exception ex)
            {
                context.ShowFillTypeDiagnostics($"NSLFT002", $"Error - {ex} on type {@class.Identifier.Text}", DiagnosticSeverity.Error, @class.GetLocation());
            }
        }

        private static string[] requiredUsings = new string[] { "System.Linq" };

        private void ProcessFillType(SourceProductionContext sourceContext, GeneratorSyntaxContext context, TypeDeclarationSyntax type)
        {
            if (!type.HasPartialModifier())
            {
                sourceContext.ShowFillTypeDiagnostics("NSLFT000", "Type must have a partial modifier", DiagnosticSeverity.Error, type.GetLocation());

                return;
            }

            var typeSem = context.SemanticModel;

            var typeSymb = typeSem.GetDeclaredSymbol(type) as ITypeSymbol;

            var codeBuilder = new CodeBuilder();

            codeBuilder.AppendComment(() =>
            {
                codeBuilder.AppendLine($"Auto Generated by NSL FillType. Please don't change this file");
            });

            codeBuilder.CreatePartialClass(type, classBuilder =>
            {
                var attrbs = type.AttributeLists
                .SelectMany(x => x.Attributes)
                .Where(x => x.GetAttributeFullName().Equals(FillTypeGenerateAttributeFullName))
                .ToArray();

                var attrbsGrouped = attrbs.GroupBy(x => x.ArgumentList.Arguments.First().GetAttributeTypeParameterValueSymbol(typeSem), TypeSymbolEqualityComparer.Instance);

                foreach (var attr in attrbsGrouped)
                {
                    ProcessAttribute(sourceContext, context, classBuilder, attr, typeSymb, typeSem, true);
                }

                attrbs = type.AttributeLists
                .SelectMany(x => x.Attributes)
                .Where(x => x.GetAttributeFullName().Equals(FillTypeFromGenerateAttributeFullName))
                .ToArray();

                attrbsGrouped = attrbs.GroupBy(x => x.ArgumentList.Arguments.First().GetAttributeTypeParameterValueSymbol(typeSem), TypeSymbolEqualityComparer.Instance);


                foreach (var attr in attrbsGrouped)
                {
                    ProcessAttribute(sourceContext, context, classBuilder, attr, typeSymb, typeSem, false);
                }

            }, requiredUsings);

            string name = type.GetTypeClassName();

            if (type.TypeParameterList?.Parameters.Any() == true)
            {
                name += "_";
                name += string.Join("_", type.TypeParameterList.Parameters.Select(x => x.Identifier.Text));

            }
            sourceContext.AddSource($"{name}.filltype.cs", codeBuilder.ToString());
        }

        private void ProcessAttribute(SourceProductionContext sourceContext, GeneratorSyntaxContext context, CodeBuilder classBuilder, IGrouping<ITypeSymbol, AttributeSyntax> attr, ITypeSymbol typeSymb, SemanticModel typeSem, bool to)
        {
            var models = attr.SelectMany(x => x.ArgumentList.Arguments
                .Skip(1)
                .Select(n => n.GetAttributeParameterValue<string>(typeSem)))
            .GroupBy(x => x)
            .Select(x => x.Key)
            .ToArray();

            if (!models.Any()) models = new string[] { null };

            var toType = attr.Key;

            bool isInternal = (toType.DeclaringSyntaxReferences.Any(x => (x?.GetSyntax() as TypeDeclarationSyntax)?.HasInternalModifier() == true));

            var methods = new List<string>();

            foreach (var item in models)
            {
                FillTypeGenerateContext fillcontext = new FillTypeGenerateContext()
                {
                    SourceContext = sourceContext,
                    Context = context
                };

                fillcontext.Next(new FillTypeGenerateItemContext()
                {
                    FromType = to ? typeSymb : toType,
                    ToType = to ? toType : typeSymb,
                    Model = item,
                    To = to,
                    SetPath = to ? "fillTo" : null,
                    GetPath = to ? null : "fillFrom"
                });

                methods.Add(CreateMethod(fillcontext, isInternal).ToString());
            }

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
            classBuilder.AppendLine(string.Join(Environment.NewLine + Environment.NewLine, methods));
#pragma warning restore RS1035 // Do not use APIs banned for analyzers declaration.HasInternalModifier()

        }

        private CodeBuilder CreateMethod(FillTypeGenerateContext context, bool @internal)
        {
            var citem = context.Current;

            CodeBuilder methodBuilder = new CodeBuilder();

            if (citem.To)
            {
                methodBuilder.AppendSummary(b =>
                {
                    b.AppendSummaryLine($"Generate for fill <see cref=\"{citem.FromType.GetTypeSeeCRef()}\"/> to  <see cref=\"{citem.ToType.GetTypeSeeCRef()}\"/>");
                });

                methodBuilder.AppendLine($"{(@internal ? "internal" : "public")} void Fill{citem.Model}To({citem.ToType.Name} fillTo)");
            }
            else
            {
                methodBuilder.AppendSummary(b =>
                {
                    b.AppendSummaryLine($"Generate for fill <see cref=\"{citem.ToType.GetTypeSeeCRef()}\"/> from <see cref=\"{citem.FromType.GetTypeSeeCRef()}\"/>");
                });

                methodBuilder.AppendLine($"{(@internal ? "internal" : "public")} void Fill{citem.Model}From({citem.FromType.Name} fillFrom)");
            }
            methodBuilder.AppendLine("{");

            methodBuilder.NextTab();

            List<string> memberLines = new List<string>();

            FillMembers(context, memberLines);

            foreach (var ml in memberLines)
            {
                methodBuilder.AppendLine($"{ml};");
            }

            methodBuilder.PrevTab();

            methodBuilder.AppendLine("}");

            return methodBuilder;
        }

        private void FillMembers(FillTypeGenerateContext context, List<string> codeLines, bool newObject = false)
        {
            var citem = context.Current;

            var fromMembers = FilterSymbols(citem.FromType.GetAllMembers().Where(x => !x.IsStatic && (x as IPropertySymbol)?.IsIndexer != true), citem.Model).ToArray();
            var toMembers = citem.ToType.GetAllMembers().Where(x => !x.IsStatic && (x as IPropertySymbol)?.IsIndexer != true).ToArray();

            //GenDebug.Break(true);

            var tabPrefix = string.Concat(Enumerable.Repeat("\t", context.Tab));

            string itemModel;

            foreach (var fromItem in fromMembers)
            {
                if (fromItem is IPropertySymbol fprop && fprop.GetMethod == null)
                    continue;

                var toItem = toMembers.FirstOrDefault(x => x.Name.Equals(fromItem.Name) && x.DeclaredAccessibility == Accessibility.Public);

                if (toItem == default)
                    continue;

                if (toItem is IPropertySymbol tprop && tprop.SetMethod == null)
                    continue;

                ITypeSymbol memberFromType = GetFromTypeForFill(fromItem, citem.ToType, citem.To);

                ITypeSymbol memberToType = GetToTypeForFill(toItem, citem.FromType, citem.To);

                if (memberFromType == null || memberToType == null)
                    continue;

                string mFillPath = $"{tabPrefix}{string.Join(".", citem.SetPath, fromItem.Name).TrimStart('.')}";
                string codeFragment = default;

                var customFillConvert = fromItem.GetAttributes()
                    .Concat(toItem.GetAttributes())
                    .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateConvertAttributeFullName))
                    .Select(x => x.ConstructorArguments[0].Value)
                    .Cast<ITypeSymbol>()
                    .ToArray();

                if (customFillConvert.Length > 0)
                {
                    Func<ISymbol, bool> methodSearch = m => m is IMethodSymbol ms
                                && ms.Name == "Convert"
                                && ms.IsStatic
                                && ms.Parameters.Length == 1
                                && SymbolEqualityComparer.Default.Equals(ms.Parameters[0].Type, memberFromType)
                                && SymbolEqualityComparer.Default.Equals(ms.ReturnType, memberToType);

                    var methods = customFillConvert.SelectMany(x => x.GetAllMembers().Where(m => m is IMethodSymbol))
                        .Where(methodSearch)
                        .Cast<IMethodSymbol>()
                        .GroupBy(x=>x, SymbolEqualityComparer.Default)
                        .Select(x => x.First())
                        .ToArray();

                    if (methods.Length == 1)
                    {
                        codeFragment = string.Join(".", citem.GetPath, fromItem.Name).TrimStart('.');

                        codeFragment = $"{methods[0].ContainingType.GetTypeFullName(false)}.Convert({codeFragment})";

                        var cresult = $"{mFillPath} = {codeFragment}";

                        if (!codeLines.Contains(cresult))
                            codeLines.Add(cresult);

                        continue;
                    }
                    else if (methods.Length > 1)
                    {
#pragma warning disable RS1035 // Не использовать API, запрещенные для анализаторов
                        context.SourceContext.ShowFillTypeDiagnostics($"NSLFT050", $"Members fill have multiple convertors for cast type {memberFromType.Name} to {memberToType.Name}. Save single of it {string.Join(Environment.NewLine, methods.Select(x=>$"{x.ContainingType}.{x.Name}"))}", DiagnosticSeverity.Error, fromItem.Locations.Concat(toItem.Locations).ToArray());
#pragma warning restore RS1035 // Не использовать API, запрещенные для анализаторов
                        continue;
                    }
                }

                var arrayItemTypeFrom = GetCollectionItemType(memberFromType);
                var arrayItemTypeTo = GetCollectionItemType(memberToType);

                if (arrayItemTypeFrom != default)
                {
                    itemModel = GetProxyModel(fromItem, citem.Model);

                    int n = 0;

                    string p = string.Empty;

                    if (citem.GetPath == null)
                        p = $"x{n}";
                    else
                        while (citem.GetPath.Contains(p = $"x{n++}")) { }

                    if (basicArrayTypes.Contains(arrayItemTypeFrom.Name) || arrayItemTypeFrom.TypeKind == TypeKind.Enum)
                    {
                        codeFragment = $"{string.Join(".", citem.GetPath, fromItem.Name).TrimStart('.')}?.Select({p} => {p}).{GetCollectionLinqConvertMethod(memberToType)}()";
                    }
                    else
                    {
                        if (!Equals(citem.Model, itemModel))
                            codeLines.Add($"// Proxy model merge from \"{citem.Model ?? "<null>"}\" to \"{itemModel}\"");

                        var nitem = context.Next(new FillTypeGenerateItemContext()
                        {
                            FromType = arrayItemTypeFrom,
                            ToType = arrayItemTypeTo,
                            Model = itemModel,
                            FieldName = toItem.Name,
                            GetPath = p,
                            SetPath = null,
                            To = citem.To
                        });

                        var amem = new List<string>();

                        FillMembers(context, amem, true);

                        context.Prev();

#pragma warning disable RS1035 // Не использовать API, запрещенные для анализаторов

                        codeFragment = $"{string.Join(".", citem.GetPath, fromItem.Name).TrimStart('.')}?.Select({p} => new {arrayItemTypeTo} {{{Environment.NewLine}" +
                            string.Join($",{Environment.NewLine}", amem) +
                            $"{Environment.NewLine}}}).{GetCollectionLinqConvertMethod(memberToType)}()";

#pragma warning restore RS1035 // Не использовать API, запрещенные для анализаторов

                    }
                }
                else
                {
                    var conversation = context.Context.SemanticModel.Compilation.ClassifyCommonConversion(memberFromType, memberToType);

                    bool mapTypes = false;

                    if (!conversation.Exists)
                    {
                        if ((memberFromType.TypeKind == memberToType.TypeKind)
                            && (memberFromType.TypeKind == TypeKind.Struct
                                || memberFromType.TypeKind == TypeKind.Structure))
                        {
                            var msg = $"Cannot fill \"{toItem.Name}\" value from {citem.FromType.Name}, members types must be equals, or can be cast, or marked for ignore";

                            context.SourceContext.ShowFillTypeDiagnostics("NSLFT001"
                                , msg
                                , DiagnosticSeverity.Error
                                , toItem.Locations.ToArray());

                            //GenDebug.Break();

                            continue;
                        }
                        else
                        {
                            mapTypes = true;
                        }
                    }

                    codeFragment = string.Join(".", citem.GetPath, fromItem.Name).TrimStart('.');

                    if (mapTypes)
                    {
                        itemModel = GetProxyModel(fromItem, citem.Model);

                        if (!Equals(citem.Model, itemModel))
                            codeLines.Add($"// Proxy model merge from \"{citem.Model ?? "<null>"}\" to \"{itemModel}\"");

                        var amem = new List<string>();

                        var nitem = context.Next(new FillTypeGenerateItemContext()
                        {
                            FromType = memberFromType,
                            ToType = memberToType,
                            Model = itemModel,
                            FieldName = toItem.Name,
                            GetPath = null,
                            SetPath = null,
                            To = citem.To
                        });

                        FillMembers(context, amem, true);

                        context.Prev();

#pragma warning disable RS1035 // Не использовать API, запрещенные для анализаторов
                        codeFragment = $"new {memberToType.GetTypeFullName(false)} {{{Environment.NewLine}" +
                            string.Join($",{Environment.NewLine}", amem) +
                            $"{Environment.NewLine}}}";
#pragma warning restore RS1035 // Не использовать API, запрещенные для анализаторов
                    }
                    else
                    {

                        if ((memberFromType.TypeKind == TypeKind.Struct || memberFromType.TypeKind == TypeKind.Structure)
                            && memberFromType.NullableAnnotation == NullableAnnotation.Annotated
                            && memberToType.NullableAnnotation != NullableAnnotation.Annotated)
                        {
                            codeFragment = $"({codeFragment}.HasValue ? {codeFragment}.Value : {(newObject ? "default" : mFillPath)})";
                        }

                        if (conversation.IsNumeric)
                            codeFragment = $"({memberToType.GetTypeFullName()}){codeFragment}";
                        else if (conversation.IsImplicit) { }
                    }
                }


                var result = $"{mFillPath} = {codeFragment}";

                if (!codeLines.Contains(result))
                    codeLines.Add(result);
            }
        }



        private IEnumerable<ISymbol> FilterSymbols(IEnumerable<ISymbol> symbols, string model)
        {
            if (model == default)
                return symbols;

            return symbols.Where(x =>
            {
                var a = x.GetAttributes().FirstOrDefault(n => n.AttributeClass.Name == (FillTypeGenerateIncludeAttributeFullName));

                if (a == null)
                    return false;

                if (a.ConstructorArguments.SelectMany(n => n.Values).Any(n => (n.Value as string).Equals(model)))
                    return true;

                return false;
            });
        }

        private string GetProxyModel(ISymbol item, string model)
        {
            var attributes = item.GetAttributes();

            var proxyAttribs = attributes.Where(x => x.AttributeClass.Name == FillTypeGenerateProxyAttributeFullName).ToArray();

            var fromModel = proxyAttribs.FirstOrDefault(x => x.ConstructorArguments.Length == 2 && x.ConstructorArguments.First().Value == model);

            if (fromModel != null)
                return (string)fromModel.ConstructorArguments[1].Value;
            else
            {
                var toModel = proxyAttribs.FirstOrDefault(x => x.ConstructorArguments.Length == 1);

                if (toModel != null)
                {
                    return (string)toModel.ConstructorArguments.First().Value;
                }
            }

            return model;
        }

        private ITypeSymbol GetFromTypeForFill(ISymbol fromItem, ITypeSymbol toType, bool dir)
        {
            if (fromItem is IPropertySymbol ps)
            {
                var ignore = !dir ? false : ps.GetAttributes()
                .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                .Any(q => !q.ConstructorArguments.Any() || q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                if (!ignore)
                {
                    //GenDebug.Break();

                    if (ps.GetMethod != null)
                        return ps.Type;
                }
            }
            else if (fromItem is IFieldSymbol fs)
            {
                var ignore = !dir ? false : fs.GetAttributes()
                .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                .Any(q => !q.ConstructorArguments.Any() || q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                if (!ignore)
                    return fs.Type;
            }

            return default;
        }

        private ITypeSymbol GetToTypeForFill(ISymbol toItem, ITypeSymbol fromType, bool dir)
        {
            if (toItem is IPropertySymbol ps)
            {
                var ignore = dir ? false : ps.GetAttributes()
                .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                .Any(q => !q.ConstructorArguments.Any() || q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(fromType.MetadataName)));

                if (!ignore)
                {
                    if (ps.GetMethod != null)
                        return ps.Type;
                }
            }
            else if (toItem is IFieldSymbol fs)
            {
                var ignore = dir ? false : fs.GetAttributes()
                .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                .Any(q => !q.ConstructorArguments.Any() || q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(fromType.MetadataName)));

                if (!ignore)
                    return fs.Type;
            }

            return default;
        }

        private ITypeSymbol GetCollectionItemType(ITypeSymbol type)
        {
            if (type.Name == stringFullName)
                return default;

            if (type is IArrayTypeSymbol arrt)
                return arrt.ElementType;

            if ((type.MetadataName.Equals(typeof(List<>).Name)
                || type.MetadataName.Equals(typeof(IList<>).Name)) && type is INamedTypeSymbol nt)
                return nt.TypeArguments.First();

            return default;
        }

        private string[] basicArrayTypes = new string[] {
            typeof(byte).Name,
            typeof(char).Name,
            typeof(sbyte).Name,
            typeof(ushort).Name,
            typeof(short).Name,
            typeof(uint).Name,
            typeof(int).Name,
            typeof(ulong).Name,
            typeof(long).Name,
            typeof(double).Name,
            typeof(float).Name,
            typeof(decimal).Name,
            typeof(string).Name,
            typeof(Guid).Name
        };

        private string GetCollectionLinqConvertMethod(ITypeSymbol type)
        {
            if (type is IArrayTypeSymbol arrt)
                return "ToArray";

            if ((type.MetadataName.Equals(typeof(List<>).Name)
                || type.MetadataName.Equals(typeof(IList<>).Name)) && type is INamedTypeSymbol nt)
                return "ToList";

            return default;
        }


        internal static readonly string FillTypeGenerateAttributeFullName = typeof(FillTypeGenerateAttribute).Name;
        internal static readonly string FillTypeFromGenerateAttributeFullName = typeof(FillTypeFromGenerateAttribute).Name;
        internal static readonly string FillTypeGenerateIgnoreAttributeFullName = typeof(FillTypeGenerateIgnoreAttribute).Name;
        internal static readonly string FillTypeGenerateIncludeAttributeFullName = typeof(FillTypeGenerateIncludeAttribute).Name;
        internal static readonly string FillTypeGenerateProxyAttributeFullName = typeof(FillTypeGenerateProxyAttribute).Name;
        internal static readonly string FillTypeGenerateConvertAttributeFullName = typeof(FillTypeGenerateConvertAttribute).Name;
        internal static readonly string stringFullName = typeof(string).Name;
    }

    public class FillTypeGenerateContext
    {
        public FillTypeGenerateItemContext Current { get; set; }
        public SourceProductionContext SourceContext { get; internal set; }
        public GeneratorSyntaxContext Context { get; internal set; }

        private Queue<FillTypeGenerateItemContext> Queue = new Queue<FillTypeGenerateItemContext>();

        public FillTypeGenerateItemContext Next(FillTypeGenerateItemContext item)
        {
            if (Queue.Count(x => x.FromType == item.FromType
                            && x.ToType == item.ToType
                            && x.Model == item.Model) > 9)
            {
                var startType = Queue.FirstOrDefault();

                throw new InvalidOperationException($"Fill recursion detected for type {item.FromType.Name} to {item.ToType.Name} with model \"{item.Model}\", in path = '<{startType?.FromType} => {startType?.ToType}>{string.Join(" => ", Queue.Select(x => $"{x.FieldName ?? "<null>"}({x.Model ?? "<null>"})"))}'");
            }

            Current = item;
            Queue.Enqueue(item);

            return Current;
        }

        public void Prev()
        {
            Current = Queue.Dequeue();
        }

        public int Tab => Queue.Count - 1;

    }

    public class FillTypeGenerateItemContext
    {
        public ITypeSymbol FromType { get; set; }

        public ITypeSymbol ToType { get; set; }

        public string Model { get; set; }

        public string GetPath { get; set; }

        public string SetPath { get; set; }

        public string FieldName { get; set; }

        public bool To { get; set; }
    }
}
