using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NSL.Generators.FillTypeGenerator.Attributes;
using NSL.Generators.Utils;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;

namespace NSL.Generators.FillTypeGenerator
{

    [Generator]
    internal class FillTypeGenerator : ISourceGenerator
    {
        #region ISourceGenerator

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is FillTypeAttributeSyntaxReceiver methodSyntaxReceiver)
            {
                ProcessFillTypes(context, methodSyntaxReceiver);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() =>
                new FillTypeAttributeSyntaxReceiver());
        }

        #endregion

        private void ProcessFillTypes(GeneratorExecutionContext context, FillTypeAttributeSyntaxReceiver methodSyntaxReceiver)
        {
            //GenDebug.Break();

            foreach (var item in methodSyntaxReceiver.FillTypeTypes)
            {
                ProcessFillToType(context, item);
            }
        }

        private static string[] requiredUsings = new string[] { "System.Linq" };

        private void ProcessFillToType(GeneratorExecutionContext context, TypeDeclarationSyntax type)
        {
            if (!type.HasPartialModifier())
                return;

            var typeClass = type as ClassDeclarationSyntax;

            var typeSem = context.Compilation.GetSemanticModel(typeClass.SyntaxTree);

            var typeSymb = typeSem.GetDeclaredSymbol(type) as ITypeSymbol;

            var classBuilder = new CodeBuilder();

            classBuilder.AppendComment(() =>
            {
                classBuilder.AppendLine($"Auto Generated by NSL FillType. Please don't change this file");
            });

            classBuilder.CreatePartialClass(typeClass, () =>
            {
                var attrbs = typeClass.AttributeLists
                .SelectMany(x => x.Attributes)
                .Where(x => x.GetAttributeFullName().Equals(FillTypeGenerateAttributeFullName))
                .ToArray();

                var attrbsGrouped = attrbs.GroupBy(x => x.ArgumentList.Arguments.First().GetAttributeTypeParameterValueSymbol(typeSem), TypeSymbolEqualityComparer.Instance);


                foreach (var attr in attrbsGrouped)
                {
                    var haveAll = attr.Any(x => x.ArgumentList.Arguments.Count() == 1);

                    var models = attr.SelectMany(x => x.ArgumentList.Arguments
                        .Skip(1)
                        .Select(n=>n.GetAttributeParameterValue<string>(typeSem)))
                    .GroupBy(x => x)
                    .Select(x => x.Key)
                    .ToArray();

                    if (models.Contains(null))
                        haveAll = false;

                    var toType = attr.Key;

                    var declaration = toType.DeclaringSyntaxReferences.First().GetSyntax() as TypeDeclarationSyntax;

                    if (haveAll)
                        classBuilder.AppendLine(CreateMethod(declaration, typeSymb, toType, null).ToString());

                    if (models.Any())
                    {
                        var methods = new List<string>();

                        foreach (var item in models)
                        {
                            methods.Add(CreateMethod(declaration, typeSymb, toType, item).ToString());
                        }

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
                        classBuilder.AppendLine(string.Join(Environment.NewLine + Environment.NewLine, methods));
#pragma warning restore RS1035 // Do not use APIs banned for analyzers
                    }
                }
            }, requiredUsings);

            // Visual studio have lag(or ...) cannot show changes sometime
            //#if DEVELOP
#pragma warning disable RS1035 // Do not use APIs banned for analyzers
            //System.IO.File.WriteAllText($@"C:\Work\temp\{typeClass.GetTypeClassName()}.filltype.cs", classBuilder.ToString());
#pragma warning restore RS1035 // Do not use APIs banned for analyzers
            //#endif

            //GenDebug.Break();

            context.AddSource($"{typeClass.GetTypeClassName()}.filltype.cs", classBuilder.ToString());
        }

        private CodeBuilder CreateMethod(TypeDeclarationSyntax declaration, ITypeSymbol fromType, ITypeSymbol toType, string model)
        {
            CodeBuilder methodBuilder = new CodeBuilder();

            //methodBuilder.AppendLine($"{(declaration.HasInternalModifier() ? "internal" : "public")} {toType.Name} Fill{model}Create()");

            //methodBuilder.AppendLine("{");

            //methodBuilder.NextTab();



            //methodBuilder.PrevTab();

            //methodBuilder.AppendLine("}");

            //methodBuilder.AppendLine();

            methodBuilder.AppendLine($"{(declaration.HasInternalModifier() ? "internal" : "public")} void Fill{model}To({toType.Name} toFill)");

            methodBuilder.AppendLine("{");

            methodBuilder.NextTab();

            List<string> memberLines = new List<string>();

            FillMembers(memberLines, fromType, toType, model, "toFill", null, 0);

            foreach (var ml in memberLines)
            {
                methodBuilder.AppendLine($"{ml};");
            }

            methodBuilder.PrevTab();

            methodBuilder.AppendLine("}");

            return methodBuilder;
        }

        private IEnumerable<ISymbol> FilterSymbols(IEnumerable<ISymbol> symbols, string model)
        {
            if (model == default)
                return symbols;

            return symbols.Where(x =>
            {
                var a = x.GetAttributes().FirstOrDefault(n => n.AttributeClass.Name == (FillTypeGenerateIncludeAttributeFullName));

                if (a == null)
                    return false;

                if (a.ConstructorArguments.SelectMany(n => n.Values).Any(n => (n.Value as string).Equals(model)))
                    return true;

                return false;
            });
        }

        private string GetProxyModel(ISymbol item, string model)
        {
            //GenDebug.Break();

            string proxyModel = default;

            var attributes = item.GetAttributes();

            var proxyAttribs = attributes.Where(x => x.AttributeClass.Name == FillTypeGenerateProxyAttributeFullName).ToArray();

            var fromModel = proxyAttribs.FirstOrDefault(x => x.ConstructorArguments.Length == 2 && x.ConstructorArguments.First().Value == model);

            if (fromModel != null)
                proxyModel = (string)fromModel.ConstructorArguments[1].Value;
            else
            {
                var toModel = proxyAttribs.FirstOrDefault(x => x.ConstructorArguments.Length == 1);

                if (toModel != null)
                    proxyModel = (string)toModel.ConstructorArguments.First().Value;
            }

            return proxyModel ?? model;
        }

        private ITypeSymbol GetFromTypeForFill(ISymbol fromItem, ITypeSymbol toType)
        {
            if (fromItem is IPropertySymbol ps)
            {
                var ignore = ps.GetAttributes()
                .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                .Any(q => q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                if (!ignore)
                {
                    if (ps.GetMethod != null)
                        return ps.Type;
                }
            }
            else if (fromItem is IFieldSymbol fs)
            {
                var ignore = fs.GetAttributes()
                .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                .Any(q => q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                if (!ignore)
                    return fs.Type;
            }

            return default;
        }

        private ITypeSymbol GetToTypeForFill(ISymbol toItem)
        {
            if (toItem is IPropertySymbol ps)
            {
                if (ps.SetMethod != null)
                    return ps.Type;
            }
            else if (toItem is IFieldSymbol fs)
            {
                return fs.Type;
            }

            return default;
        }

        private ITypeSymbol GetCollectionItemType(ITypeSymbol type)
        {
            if (type.Name == stringFullName)
                return default;

            if (type is IArrayTypeSymbol arrt)
                return arrt.ElementType;

            if ((type.MetadataName.Equals(typeof(List<>).Name)
                || type.MetadataName.Equals(typeof(IList<>).Name)) && type is INamedTypeSymbol nt)
                return nt.TypeArguments.First();

            return default;
        }

        private string[] basicArrayTypes = new string[] {
            typeof(byte).Name,
            typeof(char).Name,
            typeof(sbyte).Name,
            typeof(ushort).Name,
            typeof(short).Name,
            typeof(uint).Name,
            typeof(int).Name,
            typeof(ulong).Name,
            typeof(long).Name,
            typeof(string).Name
        };

        private string GetCollectionLinqConvertMethod(ITypeSymbol type)
        {
            if (type is IArrayTypeSymbol arrt)
                return "ToArray";

            if ((type.MetadataName.Equals(typeof(List<>).Name)
                || type.MetadataName.Equals(typeof(IList<>).Name)) && type is INamedTypeSymbol nt)
                return "ToList";

            return default;
        }

        private void FillMembers(List<string> codeLines, ITypeSymbol fromType, ITypeSymbol toType, string model, string fillPath, string readPath, int t)
        {
            var fromMembers = FilterSymbols(fromType.GetAllMembers(), model);
            var toMembers = toType.GetAllMembers();

            var tabPrefix = string.Concat(Enumerable.Repeat("\t", t));

            string itemModel;

            foreach (var fromItem in fromMembers)
            {
                var toItem = toMembers.FirstOrDefault(x => x.Name.Equals(fromItem.Name) && x.DeclaredAccessibility == Accessibility.Public);

                if (toItem == default)
                    continue;

                ITypeSymbol memberFromType = GetFromTypeForFill(fromItem, toType);

                ITypeSymbol memberToType = GetToTypeForFill(toItem);

                if (memberFromType == null || memberToType == null)
                    continue;

                string mFillPath = $"{tabPrefix}{string.Join(".", fillPath, fromItem.Name).TrimStart('.')} = ";

                string codeFragment = default;

                var arrayItemTypeFrom = GetCollectionItemType(memberFromType);
                var arrayItemTypeTo = GetCollectionItemType(memberToType);

                if (arrayItemTypeFrom != default)
                {
                    if (arrayItemTypeTo == null)
                    {
                        codeLines.Add($"Cannot convert {memberFromType} to {memberToType}");
                        continue;
                    }

                    itemModel = GetProxyModel(fromItem, model);

                    int n = 0;

                    string p = string.Empty;

                    if (readPath == null)
                        p = $"x{n}";
                    else
                        while (readPath.Contains(p = $"x{n++}")) { }

                    if (basicArrayTypes.Contains(arrayItemTypeFrom.Name))
                    {
                        codeFragment = $"{string.Join(".", readPath, fromItem.Name).TrimStart('.')}?.Select({p} => {p}).{GetCollectionLinqConvertMethod(memberToType)}()";
                    }
                    else
                    {
                        var amem = new List<string>();

                        FillMembers(amem, arrayItemTypeFrom, arrayItemTypeTo, itemModel, null, p, 1);

                        if (!Equals(model, itemModel))
                            codeLines.Add($"// Proxy model merge from \"{model}\" to \"{itemModel}\"");

                        //GenDebug.Break();

#pragma warning disable RS1035 // Не использовать API, запрещенные для анализаторов

                        codeFragment = $"{string.Join(".", readPath, fromItem.Name).TrimStart('.')}?.Select({p} => new {arrayItemTypeTo} {{{Environment.NewLine}" +
                            string.Join($",{Environment.NewLine}", amem) +
                            $"{Environment.NewLine}}}).{GetCollectionLinqConvertMethod(memberToType)}()";

#pragma warning restore RS1035 // Не использовать API, запрещенные для анализаторов

                        //                        codeLines.Add($"{item.Name} = {path}.{item.Name} == null ? null : {path}.{item.Name}.Select({p} => new {{{Environment.NewLine}{CombineMembers(amem.Select(x => $"\t{x}"))}{Environment.NewLine}}})");

                    }
                }
                else
                    codeFragment = string.Join(".", readPath, fromItem.Name).TrimStart('.');

                var result = $"{mFillPath}{codeFragment}";

                if (!codeLines.Contains(result))
                    codeLines.Add(result);
            }
        }


        private readonly string FillTypeGenerateAttributeFullName = typeof(FillTypeGenerateAttribute).Name;
        private readonly string FillTypeGenerateIgnoreAttributeFullName = typeof(FillTypeGenerateIgnoreAttribute).Name;
        private readonly string FillTypeGenerateIncludeAttributeFullName = typeof(FillTypeGenerateIncludeAttribute).Name;
        private readonly string FillTypeGenerateProxyAttributeFullName = typeof(FillTypeGenerateProxyAttribute).Name;
        private readonly string stringFullName = typeof(string).Name;
    }
}
