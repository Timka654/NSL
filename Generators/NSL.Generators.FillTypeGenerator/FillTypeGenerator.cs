using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NSL.Generators.FillTypeGenerator.Attributes;
using NSL.Generators.Utils;
using System;
using System.Collections.Generic;
using System.Linq;

namespace NSL.Generators.FillTypeGenerator
{
    [Generator]
    internal class FillTypeGenerator : ISourceGenerator
    {
        #region ISourceGenerator

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is FillTypeAttributeSyntaxReceiver methodSyntaxReceiver)
            {
                ProcessFillTypes(context, methodSyntaxReceiver);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() =>
                new FillTypeAttributeSyntaxReceiver());
        }

        #endregion

        private void ProcessFillTypes(GeneratorExecutionContext context, FillTypeAttributeSyntaxReceiver methodSyntaxReceiver)
        {
            //if (!Debugger.IsAttached)
            //    Debugger.Launch();

            foreach (var item in methodSyntaxReceiver.FillTypeTypes)
            {
                ProcessFillToType(context, item);
            }
        }

        private void ProcessFillToType(GeneratorExecutionContext context, TypeDeclarationSyntax type)
        {
            if (!type.HasPartialModifier())
                return;

            var typeClass = type as ClassDeclarationSyntax;

            var typeSem = context.Compilation.GetSemanticModel(typeClass.SyntaxTree);

            var classBuilder = new CodeBuilder();

            classBuilder.AppendComment(() =>
            {
                classBuilder.AppendLine($"Auto Generated by NSL FillType. Please don't change this file");
            });

            classBuilder.CreatePartialClass(typeClass, () =>
            {
                var attrbs = typeClass.AttributeLists
                .SelectMany(x => x.Attributes)
                .Where(x => x.GetAttributeFullName().Equals(FillTypeGenerateAttributeFullName))
                .ToArray();

                foreach (var attr in attrbs)
                {
                    //if (!Debugger.IsAttached)
                    //    Debugger.Launch();

                    var typeSymb = typeSem.GetDeclaredSymbol(type) as ITypeSymbol;

                    var fillArgs = attr.ArgumentList.Arguments;

                    var toType = fillArgs.First().GetAttributeTypeParameterValueSymbol(typeSem);

                    string[] models = null;

                    if (fillArgs.Count > 1)
                    {
                        models = fillArgs.Skip(1).Select(x => x.GetAttributeParameterValue<string>(typeSem)).ToArray();
                    }

                    var toMembers = toType.GetAllMembers();

                    var members = typeSymb.GetAllMembers();


                    var declaration = toType.DeclaringSyntaxReferences.First().GetSyntax() as TypeDeclarationSyntax;

                    if (models == null)
                        classBuilder.AppendLine(CreateMethod(declaration, members, toType, toMembers, null).ToString());
                    else
                    {
                        var methods = new List<string>();

                        foreach (var item in models)
                        {
                            methods.Add(CreateMethod(declaration, members.Where(x =>
                            {
                                var a = x.GetAttributes().FirstOrDefault(n => n.AttributeClass.Name == (FillTypeGenerateIncludeAttributeFullName));

                                if (a == null)
                                    return false;

                                if (a.ConstructorArguments.SelectMany(n => n.Values).Any(n => (n.Value as string).Equals(item)))
                                    return true;

                                return false;
                            }), toType, toMembers, item).ToString());
                        }

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
                        classBuilder.AppendLine(string.Join(Environment.NewLine + Environment.NewLine, methods));
#pragma warning restore RS1035 // Do not use APIs banned for analyzers
                    }
                }
            });

            // Visual studio have lag(or ...) cannot show changes sometime
            //#if DEVELOP
#pragma warning disable RS1035 // Do not use APIs banned for analyzers
            //System.IO.File.WriteAllText($@"C:\Work\temp\{typeClass.GetTypeClassName()}.filltype.cs", classBuilder.ToString());
#pragma warning restore RS1035 // Do not use APIs banned for analyzers
            //#endif

            context.AddSource($"{typeClass.GetTypeClassName()}.filltype.cs", classBuilder.ToString());
        }

        private CodeBuilder CreateMethod(TypeDeclarationSyntax declaration, IEnumerable<ISymbol> members, ITypeSymbol toType, IEnumerable<ISymbol> toMembers, string model)
        {
            CodeBuilder methodBuilder = new CodeBuilder();

            //methodBuilder.AppendLine($"{(declaration.HasInternalModifier() ? "internal" : "public")} {toType.Name} Fill{model}Create()");

            //methodBuilder.AppendLine("{");

            //methodBuilder.NextTab();



            //methodBuilder.PrevTab();

            //methodBuilder.AppendLine("}");

            //methodBuilder.AppendLine();

            methodBuilder.AppendLine($"{(declaration.HasInternalModifier() ? "internal" : "public")} void Fill{model}To({toType.Name} toFill)");

            methodBuilder.AppendLine("{");

            methodBuilder.NextTab();


            foreach (var item in members)
            {
                var fMember = toMembers.FirstOrDefault(x => x.Name.Equals(item.Name) && x.DeclaredAccessibility == Accessibility.Public);

                if (fMember == default || (fMember is IPropertySymbol fps && fps.SetMethod == default))
                    continue;

                if (item is IPropertySymbol ps)
                {
                    var ignore = ps.GetAttributes()
                    .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                    .Any(q => q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                    if (ignore)
                        continue;

                    if (ps.GetMethod == null)
                        continue;
                }
                else if (item is IFieldSymbol fs)
                {
                    var ignore = fs.GetAttributes()
                    .Where(x => x.AttributeClass.Name.Equals(FillTypeGenerateIgnoreAttributeFullName))
                    .Any(q => q.ConstructorArguments.Any(x => (x.Value as INamedTypeSymbol).MetadataName.Equals(toType.MetadataName)));

                    if (ignore)
                        continue;
                }
                else
                    continue;

                methodBuilder.AppendLine($"toFill.{item.Name} = {item.Name};");
            }

            methodBuilder.PrevTab();

            methodBuilder.AppendLine("}");

            return methodBuilder;
        }


        private readonly string FillTypeGenerateAttributeFullName = typeof(FillTypeGenerateAttribute).Name;
        private readonly string FillTypeGenerateIgnoreAttributeFullName = typeof(FillTypeGenerateIgnoreAttribute).Name;
        private readonly string FillTypeGenerateIncludeAttributeFullName = typeof(FillTypeGenerateIncludeAttribute).Name;
    }
}
