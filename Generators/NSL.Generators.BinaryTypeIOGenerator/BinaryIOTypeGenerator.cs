using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NSL.Generators.BinaryGenerator;
using NSL.Generators.BinaryTypeIOGenerator.Attributes;
using NSL.Generators.BinaryTypeIOGenerator.Models;
using NSL.Generators.Utils;
using NSL.SocketCore.Utils.Buffer;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace NSL.Generators.BinaryTypeIOGenerator
{
    [Generator]
    internal class BinaryIOTypeGenerator : ISourceGenerator
    {
        private void ProcessBinaryIOTypes(GeneratorExecutionContext context, BinaryIOAttributeSyntaxReceiver methodSyntaxReceiver)
        {
            //if (!Debugger.IsAttached)
            //    Debugger.Launch();

            foreach (var type in methodSyntaxReceiver.BinaryIOTypes)
            {
                ProcessBinaryIOType(context, type);
            }
        }

        private void ProcessBinaryIOType(GeneratorExecutionContext context, TypeDeclarationSyntax type)
        {
            var classDecl = type as ClassDeclarationSyntax;

            if (!type.Modifiers.Any(x => x.ValueText.Equals("partial")))
                return;


            var classIdentityName = type.Identifier.Text;

            var ns = type.Parent as NamespaceDeclarationSyntax;

            var methods = type.Members.Select(x => x as MethodDeclarationSyntax).Where(x => x != null).ToArray();

            CodeBuilder classBuilder = new CodeBuilder();

            classBuilder.AppendComment(() =>
            {
                classBuilder.AppendLine($"Auto Generated by NSL BinaryIO. Please dont change this file");
                classBuilder.AppendLine($"Project must have reference \"NSL.SocketCore\" library for normal working");
            });

            classBuilder.AppendLine($"using NSL.SocketCore;");
            classBuilder.AppendLine($"using NSL.SocketCore.Utils.Buffer;");

            var usings = UpdateUsingDirectives(type.SyntaxTree);

            foreach (var u in usings)
            {
                classBuilder.AppendLine(u.ToString());
            }

            classBuilder.AppendLine();

            var generic = classDecl.TypeParameterList?.Parameters.Any() == true ? $"<{string.Join(",", classDecl.TypeParameterList.Parameters.Select(x => x.Identifier.Text))}>" : string.Empty;


            classBuilder.AppendLine($"{classDecl.GetClassFullModifier()} class {classDecl.GetClassName()}{generic}");

            classBuilder.NextTab();

            foreach (var c in classDecl.ConstraintClauses)
            {
                classBuilder.AppendLine(c.ToString());
            }

            classBuilder.PrevTab();

            classBuilder.AppendLine("{");

            classBuilder.NextTab();


            foreach (var method in methods)
            {
                if (!method.Modifiers.Any(x => x.ValueText.Equals("partial")))
                    continue;

                var attrList = method.AttributeLists.SelectMany(x => x.Attributes).ToArray();

                var methodReadAttribute = attrList
                    .FirstOrDefault(x => x.GetAttributeFullName().Equals(ReadMethodAttributeFullName));

                var methodWriteAttribute = attrList
                    .FirstOrDefault(x => x.GetAttributeFullName().Equals(WriteMethodAttributeFullName));

                if (
                    (methodReadAttribute != null && methodWriteAttribute != null) ||
                    (methodReadAttribute == null && methodWriteAttribute == null)
                   )
                    continue;

                string forGroup = null;

                var args = (methodWriteAttribute ?? methodReadAttribute).ArgumentList?.Arguments;

                var argsMap = args?
                    .Select(x => (x.NameEquals?.Name.ToString(), x.Expression.NormalizeWhitespace().ToString()))
                    .Where(x => x.Item1 != null)
                    .ToDictionary(x => x.Item1, x => x.Item2);

                argsMap?.TryGetValue("For", out forGroup);

                var methodInfo = new MethodInfoModel()
                {
                    MethodDeclarationSyntax = method,
                    IOType = methodReadAttribute == null ? IOTypeEnum.Write : IOTypeEnum.Read,
                    ForGroup = forGroup?.Trim('\"') ?? "*",
                    Parameters = method.ParameterList.Parameters.Select(x => new parametermodel
                    {
                        name = x.Identifier.ValueText,
                        parameter = x
                    }).ToList(),
                    ClassDeclarationSyntax = classDecl
                };

                CodeBuilder methodBuilder = new CodeBuilder();

                switch (methodInfo.IOType)
                {
                    case IOTypeEnum.Read:
                        ProcessReadMethod(methodBuilder, methodInfo, context);
                        break;
                    case IOTypeEnum.Write:
                        ProcessWriteMethod(methodBuilder, methodInfo, context);
                        break;
                    default:
                        break;
                }


                classBuilder.AppendLine(methodBuilder.ToString());
            }

            classBuilder.PrevTab();

            classBuilder.AppendLine("}");

            string outputValue = classBuilder.ToString();

            if (ns != null)
            {
                var nsBuilder = new CodeBuilder();

                nsBuilder.AppendLine($"namespace {ns.Name.ToString()}");
                nsBuilder.AppendLine("{");

                nsBuilder.NextTab();

                nsBuilder.AppendLine(outputValue);

                nsBuilder.PrevTab();

                nsBuilder.AppendLine("}");

                outputValue = nsBuilder.ToString();
            }
            // Visual studio have lag(or ...) cannot show changes any time
#if !DEVELOP
            System.IO.File.WriteAllText($@"C:\Work\temp\{classIdentityName}.binaryio.cs", outputValue);
#endif

            //if (!Debugger.IsAttached)
            //    Debugger.Launch();

            context.AddSource($"{classIdentityName}.binaryio.cs", outputValue);
        }


        private void ProcessReadMethod(CodeBuilder methodBuilder, MethodInfoModel methodInfo, GeneratorExecutionContext context)
        {
            var method = methodInfo.MethodDeclarationSyntax;
            var classDecl = methodInfo.ClassDeclarationSyntax;

            methodBuilder.AppendLine($"public static partial {classDecl.GetClassName()} {method.GetMethodName()}({string.Join(", ", methodInfo.Parameters.Select(x => $"{((IdentifierNameSyntax)x.parameter.Type).Identifier.Text} {x.name}"))})");
            methodBuilder.AppendLine("{");
            methodBuilder.NextTab();

            var bufferParam = methodInfo.Parameters.FirstOrDefault(x => ((IdentifierNameSyntax)x.parameter.Type).Identifier.Text.Equals(typeof(InputPacketBuffer).Name));

            if (bufferParam == null)
            {
                methodBuilder.AppendLine($"throw new NotImplementedException(\"Required parameter with type \\\"{typeof(InputPacketBuffer).Name}\\\" not found\");");
                return;
            }

            if (bufferParam.name != "__packet")
            {
                methodBuilder.AppendLine($"var dataPacket = {bufferParam.name};");
                methodBuilder.AppendLine();
            }

            var tSym = context.Compilation.GetSemanticModel(classDecl.SyntaxTree);

            var bgContext = new BinaryGeneratorContext();

            methodBuilder.AppendLine($"return {BinaryReadMethodsGenerator.GetValueReadSegment(tSym.GetDeclaredSymbol(classDecl), bgContext, default, Enumerable.Empty<string>())};");

            methodBuilder.PrevTab();
            methodBuilder.AppendLine("}");
        }

        private void ProcessWriteMethod(CodeBuilder methodBuilder, MethodInfoModel methodInfo, GeneratorExecutionContext context)
        {
            var method = methodInfo.MethodDeclarationSyntax;
            var classDecl = methodInfo.ClassDeclarationSyntax;

            methodBuilder.AppendLine($"{string.Join(" ", method.Modifiers.Select(x => x.Text))} void {method.GetMethodName()}({string.Join(", ", methodInfo.Parameters.Select(x => $"{((IdentifierNameSyntax)x.parameter.Type).Identifier.Text} {x.name}"))})");
            methodBuilder.AppendLine("{");
            methodBuilder.NextTab();

            var typeParam = methodInfo.Parameters.FirstOrDefault(x => ((IdentifierNameSyntax)x.parameter.Type).Identifier.Text.Equals(classDecl.GetClassName()));

            var needObject = method.Modifiers.Any(x => x.Text.Equals("static"));

            var existsObject = typeParam != null;

            if (!existsObject && needObject)
            {
                methodBuilder.AppendLine($"throw new NotImplementedException(\"Required parameter with type \\\"{classDecl.GetClassName()}\\\" not found\");");
                return;
            }


            var bufferParam = methodInfo.Parameters.FirstOrDefault(x => ((IdentifierNameSyntax)x.parameter.Type).Identifier.Text.Equals(typeof(OutputPacketBuffer).Name));

            if (bufferParam == null)
            {
                methodBuilder.AppendLine($"throw new NotImplementedException(\"Required parameter with type \\\"{typeof(OutputPacketBuffer).Name}\\\" not found\");");
                return;
            }

            var typeParamName = existsObject ? typeParam.name : "this";

            if (bufferParam.name != "__packet")
            {
                methodBuilder.AppendLine($"var __packet = {bufferParam.name};");
                methodBuilder.AppendLine();
            }

            var tSym = context.Compilation.GetSemanticModel(method.SyntaxTree);

            var bgContext = new BinaryGeneratorContext();

            methodBuilder.AppendLine(BinaryWriteMethodsGenerator.BuildParameterWriter(tSym.GetDeclaredSymbol(classDecl), bgContext, typeParamName, Enumerable.Empty<string>()));


            methodBuilder.PrevTab();
            methodBuilder.AppendLine("}");
        }

        private SyntaxList<UsingDirectiveSyntax> UpdateUsingDirectives(SyntaxTree originalTree)
        {
            var rootNode = originalTree.GetRoot() as CompilationUnitSyntax;
            return rootNode.Usings;
        }

        #region ISourceGenerator

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is BinaryIOAttributeSyntaxReceiver methodSyntaxReceiver)
                ProcessBinaryIOTypes(context, methodSyntaxReceiver);
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() =>
                new BinaryIOAttributeSyntaxReceiver());
        }

        #endregion

        private readonly string ReadMethodAttributeFullName = typeof(BinaryIOReadMethodAttribute).Name;

        private readonly string WriteMethodAttributeFullName = typeof(BinaryIOWriteMethodAttribute).Name;
    }
}
