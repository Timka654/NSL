using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NSL.Generators.BinaryGenerator;
using NSL.Generators.BinaryGenerator.Utils;
using NSL.Generators.PacketHandleGenerator.Shared;
using NSL.Generators.PacketHandleGenerator.Utils;
using NSL.Generators.Utils;
using NSL.SocketCore.Utils.Buffer;
using System;
using System.Collections.Generic;
using System.Linq;

namespace NSL.Generators.PacketHandleGenerator
{
    [Generator]
    internal class NSLPHTypeGenerator : ISourceGenerator
    {
        private void ProcessNSLPHTypes(GeneratorExecutionContext context, NSLPHAttributeSyntaxReceiver methodSyntaxReceiver)
        {
#if DEBUG
            //GenDebug.Break();
#endif

            foreach (var type in methodSyntaxReceiver.BinaryIOTypes)
            {
                ProcessNSLPHType(context, type);
            }
        }

        private static string[] requiredUsings = new string[] {
            "NSL.SocketCore",
            "NSL.SocketCore.Utils.Buffer",
            "System.Linq",
            "System"
        };

        private void ProcessNSLPHType(GeneratorExecutionContext context, TypeDeclarationSyntax type)
        {
            if (!type.HasPartialModifier())
            {
                context.ShowPHDiagnostics("NSLHP000", "Type must have a partial modifier", DiagnosticSeverity.Error, type.GetLocation());
                return;
            }
            var typeClass = type as ClassDeclarationSyntax;

            var typeSem = context.Compilation.GetSemanticModel(typeClass.SyntaxTree);
            var classBuilder = new CodeBuilder();

            classBuilder.AppendComment(() =>
            {
                classBuilder.AppendLine($"Auto Generated by NSL NSLHP. Please don't change this file");
                classBuilder.AppendLine($"Project must have reference \"NSL.SocketCore\" library for normal working");
            });

            classBuilder.CreatePartialClass(typeClass, () =>
            {
                var typeAttributes = typeClass.AttributeLists
                    .SelectMany(x => x.Attributes)
                    .Where(x => x.GetAttributeFullName().Equals(NSLPHGenImplementAttributeFullName)).ToArray();

                //GenDebug.Break();

                var typeModels = typeAttributes
                    .Select(x =>
                    {
                        var attributeConstructor = context.Compilation.GetSemanticModel(x.SyntaxTree).GetSymbolInfo(x).Symbol as IMethodSymbol;

                        var attributeParameters = attributeConstructor.Parameters;

                        var args = x.ArgumentList?.Arguments;

                        var r = new HandlesData();


                        r.Type = args.Value[0].GetAttributeTypeParameterValueSymbol(typeSem);
                        r.NetworkDataType = args.Value[1].GetAttributeTypeParameterValueSymbol(typeSem);
                        r.Direction = args.Value[2].GetAttributeParameterValue<HPDirTypeEnum>(typeSem);

                        r.Modifiers = AccessModifierEnum.Private | AccessModifierEnum.Static;

                        if (attributeParameters[3].Type.ToString() == NSLPHGenAccessModifierEnumFullName)
                        {
                            r.Modifiers = args.Value[3].GetAttributeParameterValue<AccessModifierEnum>(typeSem);

                            if (Enum.GetValues(typeof(AccessModifierEnum))
                            .Cast<AccessModifierEnum>()
                            .Where(n => n < AccessModifierEnum.Static)
                            .Where(n => r.Modifiers.HasFlag(n))
                                .Count() > 3)
                                context.ShowPHDiagnostics("NSLHP001", "Have invalid modifier combination", DiagnosticSeverity.Error, attributeParameters[1].Locations.ToArray());

                            r.Models = args?
                            .Skip(4)
                            .Select(n => n.GetAttributeParameterValue<string>(typeSem))
                            .ToArray();
                        }
                        else
                            r.Models = args?
                            .Skip(3)
                            .Select(n => n.GetAttributeParameterValue<string>(typeSem))
                            .ToArray();

                        r.Packets = loadPackets(r, context);

                        return r;
                    })
                    //.GroupBy(x => x).Select(x => x.Key)
                    .ToArray();


                var partCB = new CodeBuilder();

                foreach (var item in typeModels)
                {
                    if (item.Direction == HPDirTypeEnum.Input)
                        BuildInputType(item, typeSem, partCB);
                    else
                    {
                        //throw new NotImplementedException();
                    }
                }

                classBuilder.AppendLine(partCB.ToString());


            }, requiredUsings);

            // Visual studio have lag(or ...) cannot show changes any time
            //#if DEVELOP
            //#pragma warning disable RS1035 // Do not use APIs banned for analyzers
            //            System.IO.File.WriteAllText($@"C:\Work\temp\{classIdentityName}.binaryio.cs", outputValue);
            //#pragma warning restore RS1035 // Do not use APIs banned for analyzers
            //#endif

#if DEBUG
            //GenDebug.Break();
#endif
            context.AddSource($"{typeClass.GetTypeClassName()}.ph.cs", classBuilder.ToString());
        }

        private void BuildInputType(HandlesData handle, SemanticModel typeSem, CodeBuilder classBuilder)
        {
            foreach (var item in handle.Packets)
            {
                if (item.PacketType.HasFlag(PacketTypeEnum.Message))
                    BuildInputPacketMessage(item, typeSem, classBuilder, item.PacketType.HasFlag(PacketTypeEnum.Async));
                else if (item.PacketType.HasFlag(PacketTypeEnum.Request))
                {
                    //throw new NotImplementedException();
                }
            }
        }

        private void BuildInputPacketMessage(PacketData packet, SemanticModel typeSem, CodeBuilder classBuilder, bool isAsync)
        {
            int pi = 0;
            var args = string.Join(", ", Enumerable.Repeat($"{packet.HandlesData.NetworkDataType.Name} client", 1).Concat(packet.Parameters.Select(x => $"{x.Type.Name} item{pi++}")).ToArray());

            classBuilder.AppendLine($"{packet.HandlesData.BuildModifiers()} partial void Receive{packet.Name}Handle({args});");
        }


        private PacketData[] loadPackets(HandlesData item, GeneratorExecutionContext context)
            => item.Type.GetMembers()
                        .OfType<IFieldSymbol>()
                        .Where(field => field.IsStatic && field.HasConstantValue)
                        .Select(packet =>
                        {

                            var attributes = packet.GetAttributes();

                            var attr = attributes
                            .FirstOrDefault(a => a.AttributeClass.Name == NSLPHGenAttributeFullName);

                            if (attr == null)
                                return null;

                            var args = attr.ConstructorArguments;

                            var r = new PacketData()
                            {
                                HandlesData = item,
                                PacketType = PacketTypeEnum.Message,
                                Name = packet.Name
                            };

                            if (args[0].Type.ToString() == NSLPHGenPacketTypeEnumFullName)
                            {
                                r.PacketType = (PacketTypeEnum)args[0].Value;


                                var modCount = Enum.GetValues(typeof(PacketTypeEnum))
                                .Cast<PacketTypeEnum>()
                                .Where(x => x < PacketTypeEnum.Async)
                                .Where(x => r.PacketType.HasFlag(x))
                                .Count();

                                if (modCount > 1)
                                    context.ShowPHDiagnostics("NSLHP002", "Have invalid packet type combination", DiagnosticSeverity.Error, packet.Locations.ToArray());

                                if (modCount == 0)
                                {
                                    if (r.Name.EndsWith("Request"))
                                        r.PacketType |= PacketTypeEnum.Request;
                                    else if (r.Name.EndsWith("Message"))
                                        r.PacketType |= PacketTypeEnum.Message;
                                    else
                                        context.ShowPHDiagnostics("NSLHP003", "Need to set packet type", DiagnosticSeverity.Error, packet.Locations.ToArray());
                                }


                                r.Models = args
                                .Skip(1)
                                .SelectMany(n => n.Values.Select(v => (string)v.Value))
                                .ToArray();
                            }
                            else
                            {
                                if (r.Name.EndsWith("Request"))
                                    r.PacketType = PacketTypeEnum.Request;
                                else if (r.Name.EndsWith("Message"))
                                    r.PacketType = PacketTypeEnum.Message;

                                r.Models = args
                                .Skip(0)
                                .SelectMany(n => n.Values.Select(v => (string)v.Value))
                                .ToArray();
                            }

                            loadPacket(r, attributes);

                            return r;
                        })
                        .Where(x => x != null)
                        .ToArray();

        private void loadPacket(PacketData item, System.Collections.Immutable.ImmutableArray<AttributeData> attributes)
        {
            var parameters = attributes
            .Where(a => a.AttributeClass.Name == NSLPHGenParamAttributeFullName);

            item.Parameters = parameters.Select(x =>
            {
                var r = new PacketParamData();

                r.Type = (ITypeSymbol)x.ConstructorArguments[0].Value;

                if (x.ConstructorArguments.Length > 1)
                    r.BinaryModel = (string)x.ConstructorArguments[1].Value;

                return r;
            }).ToArray();


            var result = attributes
            .FirstOrDefault(a => a.AttributeClass.Name == NSLPHGenResultAttributeFullName);

            if (result != null)
                item.Result = new PacketResultData()
                {
                    Type = (ITypeSymbol)result.ConstructorArguments[0].Value
                };
        }

        #region ISourceGenerator

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is NSLPHAttributeSyntaxReceiver methodSyntaxReceiver)
            {
                ProcessNSLPHTypes(context, methodSyntaxReceiver);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() =>
                new NSLPHAttributeSyntaxReceiver());
        }

        #endregion

        internal static readonly string NSLPHGenImplementAttributeFullName = typeof(NSLPHGenImplementAttribute).Name;

        internal static readonly string NSLPHGenAttributeFullName = typeof(NSLPHGenAttribute).Name;

        internal static readonly string NSLPHGenParamAttributeFullName = typeof(NSLPHGenParamAttribute).Name;

        internal static readonly string NSLPHGenResultAttributeFullName = typeof(NSLPHGenResultAttribute).Name;

        internal static readonly string NSLPHGenAccessModifierEnumFullName = typeof(AccessModifierEnum).FullName;

        internal static readonly string NSLPHGenPacketTypeEnumFullName = typeof(PacketTypeEnum).FullName;
    }

    internal class HandlesData
    {
        public ITypeSymbol Type { get; set; }

        public AccessModifierEnum Modifiers { get; set; }

        public HPDirTypeEnum Direction { get; set; }

        public ITypeSymbol NetworkDataType { get; set; }

        public string[] Models { get; set; }

        public PacketData[] Packets { get; set; }

        public string BuildModifiers()
            => string.Join(" ", Enum.GetValues(typeof(AccessModifierEnum))
            .Cast<AccessModifierEnum>()
            .Where(x => Modifiers.HasFlag(x))
            .Select(x => x.ToString().ToLower()));
    }

    internal class PacketData
    {
        public HandlesData HandlesData { get; set; }

        public string Name { get; set; }

        public PacketTypeEnum PacketType { get; set; }

        public string[] Models { get; set; }

        public PacketParamData[] Parameters { get; set; }

        public PacketResultData Result { get; set; }
    }

    internal class PacketParamData
    {
        public ITypeSymbol Type { get; set; }

        public string BinaryModel { get; set; }
    }

    internal class PacketResultData
    {
        public ITypeSymbol Type { get; set; }
    }
}
